---
title: 苏州大学2012年872试题
date: 2021-7-26 19:48:15
author: Ranshi
avatar: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.0/img/custom/avatar.jpg
authorLink: https://github.com/Zranshi
authorAbout: 成为更好的自己，才能守护最好的你
authorDesc:
categories: 技术
comments: true
tags:
  - 考研
  - 数据结构和算法
  - Python
keywords: 考研
description: 苏州大学2012年试题，Python解析
photos: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.45/2021.5.20/54851886_p0.jpg
---

## 数据结构

### 简述题

1. 连通分量

   无向图中的极大连通子图称为连通分量. 连通分量主要用于确定从图中的一个顶点能否
   到达图中的另一个顶点.

2. 最小生成树

   对于一个带权连通图 G=(V,E) 从中得到一个 G1=(V1,E1) 的子图. 并且这个子图为一棵
   树, 则称子图为生成树 . 最小生成树则表示在 G 的所有生成树中, 权值最小的那一类
   生成树.

3. 堆排序

   将 arr[1...n] 看成一颗完全二叉树的顺序存储结构, 利用完全二叉树中双亲结点和子
   结点的关系, 每次在当前无序区中选择关键词最大的元素.

4. 双端队列

   双端队列是指两端都可以进行入队和出队操作的队列.

5. 稀疏矩阵的压缩存储方法

   为多个值相同的元素只分配一个存储空间, 对零元素不分配存储空间.

### 散列表

假定一个待散列存储的线性表为(37,65,25,73,42,91,45,361875), 散列地址空间为 HT[12]
若采用除留余数法构造散列函数和链接法处理冲突, 试求出每一元素的散列地址, 画出最后
得到的散列表, 求出平均查找长度.

由于采用除留余数法, 可得散列函数为: H(n) = n % 11. 散列地址和元素的关系如下:

| key  | 37  | 65  | 25  | 73  | 42  | 91  | 45  | 36  | 18  | 75  |
| :--- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| addr | 4   | 10  | 3   | 7   | 9   | 3   | 1   | 3   | 7   | 9   |

因此散列表为:

| addr  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| :---- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| elem  | 45  | ##  | ##  | 25  | 37  | ##  | ##  | 73  | ##  | 42  | 65  |
| link1 | ##  | ##  | ##  | 91  | ##  | ##  | ##  | 18  | ##  | 75  | ##  |
| link2 | ##  | ##  | ##  | 36  | ##  | ##  | ##  | ##  | ##  | ##  | ##  |

因此平均查找长度为: ASL = (1\*6+2\*3+3\*1)/10 =1.5

### [单链表结点与前驱结点交换位置](https://github.com/Zranshi/suda-problem/blob/master/src/2012/1.单链表结点与前驱结点交换位置/main.py)

```py
def change(node: ListNode, i: int) -> ListNode:
    idx = 1
    head = ListNode(val=0, _next=node)
    cur = head
    while cur.next:
        if idx == i:
            node1 = cur.next
            node2 = cur.next.next
            cur.next = node2
            node1.next = node2.next
            node2.next = node1
            break
        idx += 1
        cur = cur.next
    return head.next
```

### [构造平衡二叉查找树](https://github.com/Zranshi/suda-problem/blob/master/src/2012/2.构造平衡二叉查找树/main.py)

```py
def init_balance_search_tree(n: int) -> TreeNode:
    def dfs(le: int, ri: int) -> TreeNode:
        mid = (le + ri) // 2
        return TreeNode(
            val=mid,
            left=dfs(le, mid - 1) if le != mid else None,
            right=dfs(mid + 1, ri) if ri != mid else None
        )

    return dfs(1, n)
```
