---
title: 苏州大学2010年872试题
date: 2021-7-23 12:14:15
author: Ranshi
avatar: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.0/img/custom/avatar.jpg
authorLink: https://github.com/Zranshi
authorAbout: 成为更好的自己，才能守护最好的你
authorDesc:
categories: 技术
comments: true
tags:
  - 考研
  - 数据结构和算法
  - Python
keywords: 考研
description: 苏州大学2010年试题，Python解析
photos: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.45/2021.5.20/53061497_p0.jpg
---

## 数据结构

## 简答题

1. 栈和队列有什么共同点和不同点?

   共同点: 都是一种特殊的线性表, 都仅允许顺序表的头/尾进行加入元素/删除元素的操
   作.

   不同点: 栈是一种 FILO 的数据结构, 只允许在栈顶进行加入或者删除操作, 因此最先
   加入的元素, 最后才会被推出. 队列是一种 FIFO 的数据结构, 只允许在队尾/队头加入
   元素, 队头/队尾删除元素, 因此最先加入的元素, 最先被推出.

2. 什么是矩阵的压缩存储, 试举例说明.

   矩阵的压缩存储指为多个值相同的元素只分配一个存储空间, 队零元素不分配存储空间.
   目的是节省存储空间.

   例子: 对于一个 1000\*1000 稀疏矩阵, 仅有 10 个非零数据. 若是用二维数组存储,
   则会浪费大量的空间. 但如果采用三元组顺序表方式存储, 则仅仅需要 10 组三元组就
   能存储存储数据.

## 判断, 并说明理由.

题目: 对任意一个图, 从它的某个顶点出发进行一次深度优先或广度优先搜索遍历可访问到
该图的每个顶点.

错. 如果是无向图的连通图或者有向队强连通图, 则能够访问到该图队每个顶点. 对于非连
通的无向图, 不可能一次遍历访问到所有顶点. 对于有向非强连通图则有可能一次遍历到所
有顶点.

### [单链表剔除值为 x 的结点](https://github.com/Zranshi/suda-problem/blob/master/src/2010/1.单链表剔除值为x的结点/main.py)

```py
def remove_x(node: Optional[ListNode], target: int):
    """
    删除所有节点值为target的节点, 需要注意应该判断cur.next的值.

    Args:
        node (Optional[ListNode]): 单链表
        target (int): 目标值

    Returns:
        [type]: 删除后的单链表
    """
    head = ListNode(val=-1, _next=node)
    cur = head
    while cur.next:
        if cur.next.val == target:
            cur.next = cur.next.next
        else:
            cur = cur.next
    return head.next
```

### [表达式树求值](https://github.com/Zranshi/suda-problem/blob/master/src/2010/2.表达式树求值/main.py)

```py
def calculate(t: Optional[TreeNode]) -> int:
    """
    求解计算树的值.

    Args:
        t (Optional[TreeNode]): 计算树, 叶子节点为数值, 节点为运算符.

    Returns:
        int: 求解的值.
    """
    if not t:
        return -1

    if not t.left and not t.right:
        return t.val
    return eval(f"{calculate(t.left)}{t.val}{calculate(t.right)}")
```

### [按照奇偶重新组合](https://github.com/Zranshi/suda-problem/blob/master/src/2010/3.按照奇偶重新排列/main.py)

```py
def com_even_odd(arr: List[int]) -> List[int]:
    odd, even, idx = 1, 0, 0
    while idx < len(arr) and odd < len(arr) and even < len(arr):
        if arr[idx] % 2 == 1 and idx > odd:
            arr[idx], arr[odd] = arr[odd], arr[idx]
            odd += 2
        elif arr[idx] % 2 == 0 and idx > even:
            arr[idx], arr[even] = arr[even], arr[idx]
            even += 2
        idx += 1
    return arr
```
