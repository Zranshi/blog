---
title: 苏州大学2007年872试题
date: 2021-7-5 9:54:15
author: Ranshi
avatar: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.0/img/custom/avatar.jpg
authorLink: https://github.com/Zranshi
authorAbout: 成为更好的自己，才能守护最好的你
authorDesc:
categories: 技术
comments: true
tags:
  - 考研
  - 数据结构和算法
  - Python
keywords: 考研
description: 苏州大学2007年试题，Python解析
photos: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.45/2021.5.20/51440495_p0.jpg
---

## 数据结构

### 名词解释

1. 逆波兰式: 后缀表达式, 运算符在操作数后面.
2. 自由树: 无回路的连通图.
3. 外部排序: 将待排序的记录存储在外存上, 排序时再把数据一部分一部分地调入内存进行排序. 在排序过程中需要多次进行外存和内存之间的交换, 对外存文件中的记录进行的结果仍然放到原有文件中.
4. 邻接表: 对图 G 中的每个顶点 V1 建立一个单链表, 第 i 个单链表中的结点表示依附于顶点 Vi 的边. 边表的头指针和顶点的数据信息采用顺序存储.
5. 占位程序: 缺失或未经测试的函数的简化版, 用于产生足以用于测试的值.

---

### 队列的实现方法有哪些? 试比较各种实现方法的优缺点, 并距离说明队列在计算机系统中有何应用?

1. 队列的实现方法有:
   1. 顺序队列, 即采用顺序存储结构存储队列.
   2. 链式队列, 即采用链式存储结构存储队列.
2. 各有什么优缺点:
   1. 顺序队列
      1. 优点: 可以一次性分配保证够用的空间, 效率高, 因为是基于数组的, 长度也是固定的. 可以实现动态容量.
      2. 缺点: 动态分配长度时, 效率低下.
   2. 链表队列
      1. 优点: 可以方便快速地动态增长.
      2. 缺点: 由于基于链表, 要动态创建和删除节点, 效率较低.
3. 应用
   1. 解决主机于外部设备之间的速度不匹配的问题.
   2. 解决由多用户引起的资源竞争问题.

---

### [链表的交集](https://github.com/Zranshi/suda-problem/blob/master/src/2007/1.有序单链表取交集/main.py)

```Py
def intersection(l1: ListNode, l2: ListNode) -> ListNode:
    """
    求两个有序单链表的交集, 存放在l1中.
    设置两个指针分别指向两个链表的开头, 如果两个指针指向的结点的值相同, 则表示位于交集内.
    如果不相同, 则比较两个结点的值的大小, 如果l1的大, 则移动l2的指针. 否则删除当前l1的结点.

    Args:
        l1 (ListNode): 有序单链表1
        l2 (ListNode): 有序单链表2

    Returns:
        ListNode: 交集的单链表
    """
    if not l1 or not l2:
        return l1
    h1, h2 = ListNode(0, l1), ListNode(0, l2)
    t1, t2 = h1, h2
    while t1.next and t2.next:
        # 如果相等则t1,t2移动到下一格
        if t1.next.val == t2.next.val:
            t1, t2 = t1.next, t2.next
        # 如果大于则移动t2, 直到相等或者大于t1.val
        elif t1.next.val > t2.next.val:
            t2 = t2.next
        # 如果t1.val < t2.val 则移动t1, 且跳过当前结点
        else:
            t1.next = t1.next.next
    return l1
```

---

### [合并二叉排序树](https://github.com/Zranshi/suda-problem/blob/master/src/2007/2.合并二叉排序树/main.py)

```py
def insert_node(tree: TreeNode, target: TreeNode):
    if target.val == tree.val:
        return
    elif target.val < tree.val:
        if tree.left:
            insert_node(tree.left, target)
        else:
            tree.left = target
    else:
        if tree.right:
            insert_node(tree.right, target)
        else:
            tree.right = target


def merge_search_tree(tree: TreeNode, target: TreeNode):
    def post_order(idx: TreeNode):
        if idx.left:
            post_order(idx.left)
        if idx.right:
            post_order(idx.right)
        idx.left, idx.right = None, None
        insert_node(tree, idx)

    post_order(target)
```

---

### [有向无环图的最长路径](https://github.com/Zranshi/suda-problem/blob/master/src/2007/3.有向无环图的最长路径/main.py)

```py
def longest_path(_map: dict):
    """
    使用拓扑排序，队列中保存当前结点和当前路径长度，如果没有下一个结点则更新res
    :param _map:
    :return:
    """
    from collections import deque
    dq = deque()
    length = len(_map)
    res = 0
    points = [0 for _ in range(length + 1)]
    for key in _map:
        for point in _map[key]:
            points[point] += 1
    for i in range(1, length + 1):
        if points[i] == 0:
            dq.appendleft((i, 0))
    while dq:
        idx, path = dq.pop()
        if not _map[idx]:
            res = max(res, path)
        else:
            for item in _map[idx]:
                points[item] -= 1
                if points[item] == 0:
                    dq.appendleft((item, path + 1))
    return res
```

由于在创建 points 数组时遍历了所有的边，在 bfs 时遍历了所有的点，所以时间复杂度为 O(V+E)
