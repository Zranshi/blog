---
title: 苏州大学2006年872试题 
date: 2021-7-04 17:41:15 
author: Ranshi
avatar: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.0/img/custom/avatar.jpg
authorLink: https://github.com/Zranshi
authorAbout: 成为更好的自己，才能守护最好的你 
authorDesc:
categories: 技术 
comments: true 
tags:
- 考研
- 数据结构和算法
- Python 
keywords: 考研 
description: 苏州大学2006年试题，Python解析
photos: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.45/2021.5.20/54514426_p0.jpg

---


## [二叉树子树连成链表](https://github.com/Zranshi/suda-problem/blob/master/src/2006/1.将二叉树的叶结点按照从左到右的顺序连成链表/main.py)

```Python
def leaves_list(tree: TreeNode) -> LinkList:
    """
    栈实现
    :param tree:
    :return:
    """
    head = LinkList()
    stack = [tree]
    while stack:
        idx = stack.pop()
        if not idx.left and not idx.right:
            head.push_tail(idx.val)
            continue
        if idx.right:
            stack.append(idx.right)
        if idx.left:
            stack.append(idx.left)
    return head


def leaves_list_rec(tree: TreeNode) -> LinkList:
    """
    递归实现
    :param tree: 
    :return: 
    """
    head = LinkList()

    def dfs(root: TreeNode):
        if not root.left and not root.right:
            head.push_tail(root.val)
        else:
            if root.left:
                dfs(root.left)
            if root.right:
                dfs(root.right)

    dfs(tree)
    return head
```

[ 需要注意，使用stack模拟递归时，后进栈的反而先出来，因此应该先放进右节点，再放入左节点 ]

## [字符串匹配（以后的考试不做要求）](https://github.com/Zranshi/suda-problem/blob/master/src/2006/2.串的模式匹配（首位匹配）/main.py)

```Python
def index(s: str, t: str) -> int:
    length_s = len(s)
    length_t = len(t)
    if length_t == 0 or length_s == 0:
        return -1
    for i in range(0, length_s - length_t - 1):
        if s[i] == t[0] and s[i + length_t - 1] == t[-1]:
            if s[i:i + length_t] == t:
                return i
    return -1
```

## [归并排序链表](https://github.com/Zranshi/suda-problem/blob/master/src/2006/3.归并排序单链表/main.py)

```Python
def merge_sort_ln(head: ListNode) -> ListNode:
    def merge_ln(h1: ListNode, h2: ListNode) -> ListNode:
        d_h = ListNode()
        t, t1, t2 = d_h, h1, h2
        while t1 and t2:
            if t1.val <= t2.val:
                t.next, t1 = t1, t1.next
            else:
                t.next, t2 = t2, t2.next
            t = t.next
        if t1:
            t.next = t1
        else:
            t.next = t2
        return d_h.next

    def sort_func(h: ListNode, tail: ListNode = None) -> ListNode:
        if not h:
            return h
        if h.next == tail:
            h.next = None
            return h
        slow = fast = h
        while fast != tail:
            slow, fast = slow.next, fast.next
            if fast != tail and fast:
                fast = fast.next
        mid = slow
        return merge_ln(sort_func(h, mid), sort_func(mid, tail))

    return sort_func(head)
```
