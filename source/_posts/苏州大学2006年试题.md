---
title: 苏州大学2006年872试题
date: 2021-7-04 17:41:15
author: Ranshi
avatar: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.0/img/custom/avatar.jpg
authorLink: https://github.com/Zranshi
authorAbout: 成为更好的自己，才能守护最好的你
authorDesc:
categories: 技术
comments: true
tags:
  - 考研
  - 数据结构和算法
  - Python
keywords: 考研
description: 苏州大学2006年试题，Python解析
photos: https://cdn.jsdelivr.net/gh/Zranshi/CDN@1.45/2021.5.20/54514426_p0.jpg
---

## 数据结构

### 名词解释

1. 堆栈: 只允许在一端进行插入和删除操作的线性表
2. 最小生成树: 对一个带权连通无向图 G=(V, E), 生成树不同, 每棵树的权也可能不同. 设 R 为 G 的所有生成树的集合, 若 T 为 R 中边的权值之和最小的那棵生成树, 则 T 称为 G 的最小生成树.
3. 折半查找: 用于有序的顺序表, 首先将给定的 key 与表中中间位置的元素的关键字比较, 若相等, 则查找成功, 返回该元素的存储位置, 若不等, 则所需查找的元素只能在中间元素以外的前半部分或后半部分中, 缩小范围, 继续查找.
4. 堆排序: 将 arr[1...n] 看成一颗万全二叉树的顺序存储结构, 利用完全二叉树中双亲结点和子结点的关系, 每次在当前无序区中选择关键词最大的元素.
5. 连通分量: 无向图的极大连通子图

### 依次像队列和双端队列输入[1, 2 , 3, 4, 5, 6], 是否可以得到一下输出.

略.

### [二叉树叶结点放入动态分配顺序存储结构的顺序表](https://github.com/Zranshi/suda-problem/blob/master/src/2006/1.二叉树叶结点放入动态分配顺序存储结构的顺序表/main.py)

```Python
def leaves_list(tree: TreeNode) -> list:
    """
    二叉树叶结点放入动态分配顺序存储结构的顺序表.
    采用dfs算法搜索从左到右搜索叶结点.
    由于python的list本身就为动态分配的顺序存储结构, 其他语言需要在加入新元素后扩大容量
    每次扩大为当前容量大两倍.

    Args:
        tree (TreeNode): 树根节点.

    Returns:
        list: 动态分配的保存叶结点顺序存储结构.
    """
    head = []

    def dfs(root: TreeNode):
        if not root.left and not root.right and root.val != -1:
            head.append(root.val)
        else:
            if root.left:
                dfs(root.left)
            if root.right:
                dfs(root.right)

    dfs(tree)
    return head
```

### [字符串匹配（以后的考试不做要求）](https://github.com/Zranshi/suda-problem/blob/master/src/2006/2.串的模式匹配（首位匹配）/main.py)

```Python
def index(source: str, target: str) -> int:
    """
    字符串定位操作.
    在字符串中找到目标字符串的起始下标.
    在定位操作过程中, 首先定位目标字符串的首尾, 如果首位字符符合, 再匹配中间字符.

    Args:
        source (str): 源字符串.
        target (str): 目标字符串.

    Returns:
        int: 目标字符串在源字符串的起始下标.
    """
    len_s = len(source)
    len_t = len(target)
    if len_t == 0 or len_s == 0:
        return -1
    for i in range(0, len_s - len_t - 1):
        if source[i] == target[0] and source[i + len_t - 1] == target[-1]:
            if source[i:i + len_t] == target:
                return i
    return -1
```

### [归并排序链表](https://github.com/Zranshi/suda-problem/blob/master/src/2006/3.归并排序单链表/main.py)

```Python
def merge_sort_ln(head: ListNode) -> Optional[ListNode]:
    """
    归并排序算法排序单链表.

    Args:
        head (ListNode): 单链表的头结点.

    Returns:
        Optional[ListNode]: 排序后的单链表头结点.
    """

    def merge_ln(h1: Optional[ListNode],
                 h2: Optional[ListNode]) -> Optional[ListNode]:
        """
        合并函数. 将两个排序好的单链表合并为一个排序好的单链表.

        Args:
            h1 (Optional[ListNode]): 第一个排序好的单链表.
            h2 (Optional[ListNode]): 第二个排序好的单链表.

        Returns:
            Optional[ListNode]: 合并完成的单链表.
        """
        d_h = ListNode()
        t, t1, t2 = d_h, h1, h2
        while t1 and t2:
            if t1.val <= t2.val:
                t.next, t1 = t1, t1.next
            else:
                t.next, t2 = t2, t2.next
            t = t.next
        if t1:
            t.next = t1
        else:
            t.next = t2
        if not d_h.next:
            return None
        return d_h.next

    def sort_func(h: Optional[ListNode],
                  tail: Optional[ListNode] = None) -> Optional[ListNode]:
        """
        递归拆分函数. 拆分直到头结点和尾结点中间仅剩一个结点, 或者没有结点.
        采用快慢指针的方式找到头尾结点的中间结点, 然后拆分为两部分.

        Args:
            h (Optional[ListNode]): 拆分的头结点
            tail (Optional[ListNode], optional): 拆分的尾结点. Defaults to None.

        Returns:
            Optional[ListNode]: 返回排序好的单链表.
        """
        if not h:
            return h
        if h.next == tail:
            h.next = None
            return h
        slow = fast = h
        while slow and fast and fast != tail:
            slow, fast = slow.next, fast.next
            if fast != tail and fast:
                fast = fast.next
        mid = slow
        return merge_ln(sort_func(h, mid), sort_func(mid, tail))

    return sort_func(head)
```

## 操作系统

### 判断下列说法是否正确, 并说明理由

#### 在单 CPU 的计算机系统中, 进程是不能并行操作的.

#### 在死锁发生后, 参与死锁的所有进程都占有资源.

#### 存储管理中的请求分页系统必定需要重新定位机制的支持.
